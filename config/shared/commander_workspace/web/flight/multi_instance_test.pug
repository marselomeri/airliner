extends ../common/layout

block header
        i.fa-fw.fa.fa-signal
        | Multi Instance Test

block main 
  .row              
    article.col-xs-12.col-sm-12.col-md-6.col-lg-6
      #wid-Flight-HUD.jarviswidget.jarviswidget-color-blueDark(data-widget-editbutton='false',data-widget-colorbutton='false',data-widget-deletebutton='false')
        header
          span.widget-icon
            i.fa.fa-table
          h2 Attitude Indicator
        div
          .jarviswidget-editbox
            input.form-control(type='text')
          .widget-body.no-padding(style="height:500px")
            #touchpad
              #hud.no-padding 
            
    article.col-xs-12.col-sm-12.col-md-6.col-lg-6
      #wid-map.jarviswidget.jarviswidget-color-blueDark(data-widget-editbutton='false',data-widget-colorbutton='false',data-widget-deletebutton='false')
        header
          span.widget-icon
            i.fa.fa-table
          h2 Map
        div
          .jarviswidget-editbox
            input.form-control(type='text')
          .widget-body.no-padding(style="height:500px")
            style.
              @import url(bower_components/cesium/Source/Widgets/widgets.css);
            #cesiumContainer.fullSize(style="height:500px")
  .row.row-fluid
    article.col-xs-12.col-sm-12.col-md-12.col-lg-12
      #wid-Flight-Controls.jarviswidget.jarviswidget-color-blueDark(data-widget-editbutton='false',data-widget-colorbutton='false',data-widget-deletebutton='false')
        header
          span.widget-icon
            i.fa.fa-table
          h2 Controls
        div
          .jarviswidget-editbox
            input.form-control(type='text')
          .widget-body.center
            .btn-group-vertical.btn-group-lg.btn-space
                button.btn.btn-primary(data-sage={cmd: {name: '/CFS/PX4/VehicleLaunch'}}) Launch
                button.btn.btn-primary(data-sage={cmd: {name: '/CFS/PX4/VehicleLand'}}) Land
            .btn-group.btn-group-lg.btn-space
                button.btn.btn-primary(data-sage={cmd: {name: '/CFS/PX4/VehicleArm'}}) Arm
                button.btn.btn-primary(data-sage={cmd: {name: '/CFS/PX4/VehicleDisarm'}}) Disarm
            .btn-group-vertical.btn-group-lg.btn-space
                button.btn.btn-primary(data-sage={cmd: {name: '/CFS/PX4/VehicleChangeMode'}}) Set Mode
                
    article.col-xs-12.col-sm-12.col-md-6.col-lg-6
      #wid-Flight-HUD.jarviswidget.jarviswidget-color-blueDark(data-widget-editbutton='false',data-widget-colorbutton='false',data-widget-deletebutton='false')
        header
          span.widget-icon
            i.fa.fa-table
          h2 Gamepad
        div
          .jarviswidget-editbox
            input.form-control(type='text')
          .widget-body.no-padding(style="height:500px")
            #gamepadPrompt
            #gamepadDisplay

  script.
          var hasGP = false;
    var repGP;
	    
    function canGame() {
      return "getGamepads" in navigator;
    }

    function reportOnGamepad() {
      var gp = navigator.getGamepads()[0];
      var html = "";
      html += "id: "+gp.id+"<br/>";
		
      for(var i=0;i<gp.buttons.length;i++) {
        html+= "Button "+(i+1)+": ";
        if(gp.buttons[i].pressed) html+= " pressed";
          html+= "<br/>";
      }
		
      for(var i=0;i<gp.axes.length; i+=2) {
        html+= "Stick "+(Math.ceil(i/2)+1)+": "+gp.axes[i]+","+gp.axes[i+1]+"<br/>";
      }
          
      $("#gamepadDisplay").html(html);
       
      var X = gp.axes[2] * 1000;
      var Y = gp.axes[3] * 1000;
      var Z = (gp.axes[1] * -500) + 500;
          
      session.sendCommand('/CFS/PX4/ManualControlSetpoint', [
        {name:'X', value:Math.round(X).toString()},
        {name:'Y', value:Math.round(Y).toString()},
        {name:'Z', value:Math.round(Z).toString()},
        {name:'InputMask', value:'0x7000000'}
      ]);
      }
	    
      if(canGame()) {
        var prompt = "To begin using your gamepad, connect it and press any button!";
        $("#gamepadPrompt").text(prompt);
          	
        $(window).on("gamepadconnected", function() {
          hasGP = true;
          $("#gamepadPrompt").html("Gamepad connected!");
          console.log("connection event");
          repGP = window.setInterval(reportOnGamepad,100);
        });
        
        $(window).on("gamepaddisconnected", function() {
          console.log("disconnection event");
          $("#gamepadPrompt").text(prompt);
          window.clearInterval(repGP);
        });

        //setup an interval for Chrome
        var checkGP = window.setInterval(function() {
          console.log('checkGP');
          if(navigator.getGamepads()[0]) {
            if(!hasGP) $(window).trigger("gamepadconnected");
            window.clearInterval(checkGP);
          }
        }, 500);
      }
    
      loadScript('node_modules/cesium/Build/CesiumUnminified/Cesium.js', function(){
      
        Cesium.BingMapsApi.defaultKey = 'Anb5ZQS9_Qvje--nom_9ZKwQyQVnOOU04Fctd1uxMHnYoQKIcp1XFDrZuXN6evOQ';
        var viewer = new Cesium.Viewer('cesiumContainer');
      
        var uas = viewer.entities.add({
            billboard : {
                image : 'ws/flight/triangle.png',
                scale : 0.5,
                alignedAxis : Cesium.Cartesian3.UNIT_Z
            }
        });

        var scratchCartesian3 = new Cesium.Cartesian3();
        var ellipsoid = viewer.scene.mapProjection.ellipsoid;
	
        session.on('connect', function() {
            var HUDCount = 0;
            var HUDStarted = false;
            var GPSCount = 0;
            var GPSStarted = false;
            var GPSAnimating = false;
            var Lat = {value: 0, time: 1, utcTime: ''};
            var Lon = {value: 0, time: 2, utcTime: ''};
            var Alt = {value: 0, time: 1, utcTime: ''};
            var Yaw = {value: 0, time: 1, utcTime: ''};
            var Pitch = {value: 0, time: 1, utcTime: ''};
            var Roll = {value: 0, time: 1, utcTime: ''};

            session.subscribe({name: '/MAV/CMN/GPI_lat'}, function(param) {
                Lat.value = param.engValue.sint32Value / 10000000.0;
                Lat.time = param.acquisitionTime;
                Lat.utcTime = param.acquisitionTimeUTC;
                GPSCorrelateData();
                Position.Lat = Lat.value;
            });

            session.subscribe({name: '/MAV/CMN/GPI_lon'}, function(param) {
                Lon.value = param.engValue.sint32Value / 10000000.0;
                Lon.time = param.acquisitionTime;
                Lon.utcTime = param.acquisitionTimeUTC;
                GPSCorrelateData();
                Position.Lon = Lon.value;
            });

            session.subscribe({name: '/MAV/CMN/GPI_alt'}, function(param) {
                Alt.value = (param.engValue.sint32Value / 1000.0) - 488.0;
                Alt.time = param.acquisitionTime;
                Alt.utcTime = param.acquisitionTimeUTC;		
                Position.Alt = Alt.value;
                GPSCorrelateData(); 
                updateHUDAltitude(Alt.value);
                uas.position = Cesium.Cartesian3.fromDegrees(Position.Lon, Position.Lat);
            });

            session.subscribe({name: '/MAV/CMN/GPI_hdg'}, function(param) {
                Attitude.Yaw = param.engValue.uint32Value / 100;
            });

            session.subscribe({name: '/MAV/CMN/A_pitch'}, function(param) {
                Attitude.Pitch = param.engValue.floatValue;
            });

            session.subscribe({name: '/MAV/CMN/A_roll'}, function(param) {
                Attitude.Roll = param.engValue.floatValue;
            });

            var Position = {Lat: 0, Lon: 0, Alt: 0};
            var Attitude = {Yaw: 0, Pitch: 0, Roll: 0};

            var GPSCorrelateData = function () {
                if((Lat.time == Lon.time ) && ( Lon.time == Alt.time)){
                    if(GPSStarted == false){
                        /* Skip the first one. */
                        GPSStarted = true;
                    } else {
                        Position.Lon = Lon.value;
                        Position.Lat = Lat.value;
                        Position.Alt = Alt.value; 
                        GPSCount++;
                    }
                }
            };

            var HUDCorrelateData = function () {
                if((Yaw.time == Pitch.time ) && ( Pitch.time == Roll.time)){
                    if(HUDStarted == false){
                        /* Skip the first one. */
                        HUDStarted = true;
                    } else {
                        Attitude.Yaw = Yaw.value;
                        Attitude.Pitch = Pitch.value; 
                        Attitude.Roll = Roll.value;
                        HUDCount++;
                    }
                }
            };

            setInterval(function() {
                if((GPSStarted == true) && (GPSAnimating == false))
                {
                    GPSAnimating = true;    
                    viewer.camera.flyTo({
                        destination : Cesium.Cartesian3.fromDegrees( Lon.value, Lat.value, 100),
                        complete: function () { GPSAnimating = false; }
                    });   
                } 
            }, 100);

            setInterval(function() {
                //if(HUDStarted == true)
                //{
                    //updateHUDAltitude(Position.Alt); 
                    updateHUDHeading(Attitude.Yaw);
                    updateHUDPitch(Attitude.Pitch * 57.2958);
                    updateHUDRoll(Attitude.Roll * 57.2958);
                    //console.log(Attitude.Pitch);
                //} 
            }, 10);

        });


        //flyToLocation();
      });

     


      var draw;
      var curHeading = 0;
      var curPitch = 0;
      var curRoll = 0;
      var curAltitude = 0.0;
      var textHeading;
      var hdTicks;
      var hdTicksMask;
      var hdWidth;
      var hudHeight;
      var hudWidth;
      var pxPer15Degrees;
      var pxPerDegree;
      var degPerPitchLine = 15;
      var posPitchLineOnScreen = 3.5;
      var pxPerPitchLine;
      var pxPerDegreePitch;
      var pitchIndicator;
      var altPosMetersOnScreen = 5;
      var altPxPerMeter;
      var altitudeIndicator;
      var textAltitude;
      var altTicks;
      var OffsetY = 0;
      var rotation = 0;
      var hrzWidth;
      
      drawHUD();
             
      function updateHUDHeading(newHeading)
      {
        textHeading.text(newHeading.toFixed(0).toString());
        hdTicks.x(-newHeading*pxPerDegree);
      }
        
      function updateHUDPitch(newPitch)
      {
        OffsetY = newPitch*pxPerDegreePitch;
        //pitchIndicator.rotate(0); 
        //pitchIndicator.y(0);
        //pitchIndicator.animate(10, '-', 0).y(OffsetY).rotate(rotation); 
      }
        
      function updateHUDRoll(newRoll)
      {
        rotation = newRoll;
        pitchIndicator.rotate(0); 
        pitchIndicator.y(0);
        pitchIndicator.y(OffsetY).rotate(rotation); 
      }
        
      function updateHUDAltitude(newAltitude)
      {
        textAltitude.text(newAltitude.toFixed(1).toString());
        altTicks.y(newAltitude*altPxPerMeter);
      }
    
      $('#hud').on('resize', function(event) {
        console.log("Resized");
        $('svg').remove();
        drawHUD();
        //updateHUDAltitude(10);
        //updateHUDHeading(20);
        //updateHUDPitch(30);
        //updateHUDRoll(40);
      });
      
      
      function drawHUD()
      {
        var aspectRatio = 320.0 / 200.0;
        hudWidth = $('#hud').width();
        hudHeight = hudWidth / aspectRatio;
        if($( window ).height() < hudHeight)
        {
          hudHeight = $( window ).height()-50;
          hudWidth = hudHeight * aspectRatio;
        }
        draw = SVG('hud').size('100%', hudHeight);
        
        if (SVG.supported == false) 
        {
          alert('SVG not supported with ths browser.');
        } 
        else 
        {
          var bgOpacity = 0.5;
          var rect = draw.rect('100%', '100%').attr({ fill: '#000000' });
          //draw.fixSubPixelOffset();
          draw.attr('preserveAspectRatio', 'x320Y200 meet');
          var rollIndicator = draw.group();
          
          /* -------------------------
                 Draw altimeter
             ------------------------- */
          var altWidth = 50;
          var altHeight = hudHeight - 10;
          var altWidth = 50;
          var altHeight = hudHeight - 10;
          altPxPerMeter = altHeight / altPosMetersOnScreen;
          var altPxPerDecimeter = altPxPerMeter / 10.0;
          var altPxPerCentimeter = altPxPerMeter / 100.0;
          var altPxPerMillimeter = altPxPerMeter / 1000.0;
          
          var altimeter = draw.group();
          var altBorder = altimeter.group();
          /* Draw border. */
          var altRec1 = altBorder.rect(altWidth, altHeight).attr({ 
            x: hudWidth-altWidth-5, 
            y: 5, 
            stroke: '#ffffff',
            'stroke-width': '3px',
            rx: 5,
            ry: 5,
            'fill-opacity': bgOpacity
          });
          var altRec2 = altBorder.rect(altWidth, altHeight).attr({ 
            x: hudWidth-altWidth-5, 
            y: 5, 
            stroke: '#00ff00',
            rx: 5,
            ry: 5,
            'fill-opacity': bgOpacity
          });
          /* Draw ticks group. */
          var altTicksArea = altimeter.group();
          altTicks = altTicksArea.group();
          for(i = 0; i < (10*(altPosMetersOnScreen+1+30)); i++)
          {
            y = (hudHeight/2)-i*(altPxPerDecimeter);
            /* Draw a longer line if its a meter interval. */
            if(i % 10 == 0)
            {
              altTicks.line(hudWidth-altWidth-3, y, hudWidth-altWidth+20, y).attr({
                width: 2,
                stroke: '#00ff00'
              });
              
              var textAltTick = altTicks.text((i/10.0).toString()).move(hudWidth-altWidth+30,y-5);
              textAltTick.font({
                fill: '#00ff00',
                anchor: 'start',
                size: 13
              });
            }
            else
            {
              /* This is just a decimeter tick. */
              altTicks.line(hudWidth-altWidth-3, y, hudWidth-altWidth+10, y).attr({
                width: 1,
                stroke: '#00ff00'
              });
            }
          }
          for(i = 0; i > (-10*(altPosMetersOnScreen+1)); i--)
          {
            y = (hudHeight/2)-i*(altPxPerDecimeter);
            /* Draw a longer line if its a meter interval. */
            if(i % 10 == 0)
            {
              altTicks.line(hudWidth-altWidth-3, y, hudWidth-altWidth+20, y).attr({
                width: 2,
                stroke: '#00ff00'
              });
              
              var textAltTick = altTicks.text((i/10.0).toString()).move(hudWidth-altWidth+30,y-5);
              textAltTick.font({
                fill: '#00ff00',
                anchor: 'start',
                size: 13
              });
            }
            else
            {
              /* This is just a decimeter tick. */
              altTicks.line(hudWidth-altWidth-3, y, hudWidth-altWidth+10, y).attr({
                width: 1,
                stroke: '#00ff00'
              });
            }
          }
          /* Draw center altitude indicator. */
          var altCenter = altimeter.group();
          var altCenterHeight = 30;
          altCenter.polyline([
            [hudWidth-altWidth-5, hudHeight/2],
            [hudWidth-altWidth+15, (hudHeight-altCenterHeight)/2],
            [hudWidth-5, (hudHeight-altCenterHeight)/2],
            [hudWidth-5, (hudHeight+altCenterHeight)/2],
            [hudWidth-altWidth+15, (hudHeight+altCenterHeight)/2],
            [hudWidth-altWidth-5, hudHeight/2]]).attr({
              stroke: '#ffffff',
              'stroke-width': 3,
              'fill-opacity': 0.0
          });
          altCenter.polyline([
            [hudWidth-altWidth-5, hudHeight/2],
            [hudWidth-altWidth+15, (hudHeight-altCenterHeight)/2],
            [hudWidth-5, (hudHeight-altCenterHeight)/2],
            [hudWidth-5, (hudHeight+altCenterHeight)/2],
            [hudWidth-altWidth+15, (hudHeight+altCenterHeight)/2],
            [hudWidth-altWidth-5, hudHeight/2]]).attr({
            stroke: '#00ff00',
            'stroke-width': 2,
            'fill-opacity': 0.0         
          });
          textAltitude = altCenter.text('0.0').move(hudWidth-altWidth+14, (hudHeight/2)-9);
          //textAltitude.attr("dominant-baseline", "middle");
          textAltitude.font({
            fill: '#00ff00',
            size: 18
          });
          var altTicksMask = altimeter.mask();
          altTicksMask.rect(hudWidth, hudHeight).attr({
            fill: '#000000'         
          });
          altTicksMask.rect(altWidth, altHeight).attr({ 
            x: hudWidth-altWidth-5, 
            y: 5, 
            fill: '#ffffff',
            'stroke-width': '3px',
            rx: 5,
            ry: 5
          });
          altTicksMask.polyline([
            [hudWidth-altWidth-5, hudHeight/2],
            [hudWidth-altWidth+15, (hudHeight-altCenterHeight)/2],
            [hudWidth-5, (hudHeight-altCenterHeight)/2],
            [hudWidth-5, (hudHeight+altCenterHeight)/2],
            [hudWidth-altWidth+15, (hudHeight+altCenterHeight)/2],
            [hudWidth-altWidth-5, hudHeight/2]]).attr({
            fill: '#000000'         
          });
          altTicksArea.maskWith(altTicksMask);
          
          /* -------------------------
                    Draw Heading
             ------------------------- */
          var hdHeight = 50;
          hdWidth = hudWidth - 120;
          pxPer15Degrees = (hdWidth/2) / 5;
          pxPerDegree = pxPer15Degrees / 15.0;
          var heading = draw.group();
          var headingBorder = heading.group();
          /* Draw border. */
          var hdRec1 = headingBorder.rect(hdWidth, hdHeight).attr({ 
            x: (hudWidth-hdWidth)/2, 
            y: hudHeight-hdHeight-5, 
            stroke: '#ffffff',
            'stroke-width': '3px',
            rx: 5,
            ry: 5,
            'fill-opacity': bgOpacity
          });
          var hdRec2 = headingBorder.rect(hdWidth, hdHeight).attr({  
            x: (hudWidth-hdWidth)/2, 
            y: hudHeight-hdHeight-5, 
            stroke: '#00ff00',
            'stroke-width': '1px',
            rx: 5,
            ry: 5,
            'fill-opacity': bgOpacity
          });
          /* Draw ticks group. */
          hdTicksArea = heading.group();
          hdTicks = hdTicksArea.group();
          for(i = 0; i < (360+90); i++)
          {
            if(i % 15 == 0)
            {
              x = ((hudWidth)/2) + (pxPerDegree * i);
              console.log(x);
              hdTicks.line(x, hudHeight-hdHeight-3, x, hudHeight-hdHeight+10).attr({
                width: 1,
                stroke: '#00ff00'
              });
              
              var fixedHeading = i;
              if(i < 0)
              {
                fixedHeading = 360 + i;
              }
              else if(i >= 360)
              {
                fixedHeading = i - 360;
              }
              
              var textHeadingTick = hdTicks.text(fixedHeading.toString()).move(x,hudHeight-hdHeight+13);
              textHeadingTick.font({
                fill: '#00ff00',
                anchor: 'middle',
                size: 13
              });
            }
          }
          for(i = 0; i > (-360-90); i--)
          {
            if(i % 15 == 0)
            {
              x = ((hudWidth)/2) + (pxPerDegree * i);
              hdTicks.line(x, hudHeight-hdHeight-3, x, hudHeight-hdHeight+10).attr({
                width: 1,
                stroke: '#00ff00'
              });
              
              var fixedHeading = i;
              if(i < 0)
              {
                fixedHeading = 360 + i;
              }
              else if(i >= 360)
              {
                fixedHeading = i - 360;
              }
              
              var textHeadingTick = hdTicks.text(fixedHeading.toString()).move(x,hudHeight-hdHeight+13);
              textHeadingTick.font({
                fill: '#00ff00',
                anchor: 'middle',
                size: 13
              });
            }
          }
          /* Draw center heading indicator. */
          var hdCenter = heading.group();
          var hdCenterWidth = 60;
          hdCenter.polyline([
            [hudWidth/2, hudHeight-hdHeight-5],
            [(hudWidth+20)/2, hudHeight-hdHeight+10],
            [(hudWidth+hdCenterWidth)/2, hudHeight-hdHeight+10],
            [(hudWidth+hdCenterWidth)/2, hudHeight-5],
            [(hudWidth-hdCenterWidth)/2, hudHeight-5],
            [(hudWidth-hdCenterWidth)/2, hudHeight-hdHeight+10],
            [(hudWidth-20)/2, hudHeight-hdHeight+10],
            [hudWidth/2, hudHeight-hdHeight-5]]).attr({
              stroke: '#ffffff',
              'stroke-width': 3,
              'fill-opacity': 0.0
          });
          hdCenter.polyline([
            [hudWidth/2, hudHeight-hdHeight-5],
            [(hudWidth+20)/2, hudHeight-hdHeight+10],
            [(hudWidth+hdCenterWidth)/2, hudHeight-hdHeight+10],
            [(hudWidth+hdCenterWidth)/2, hudHeight-5],
            [(hudWidth-hdCenterWidth)/2, hudHeight-5],
            [(hudWidth-hdCenterWidth)/2, hudHeight-hdHeight+10],
            [(hudWidth-20)/2, hudHeight-hdHeight+10],
            [hudWidth/2, hudHeight-hdHeight-5]]).attr({
              stroke: '#00ff00',
              'stroke-width': 2,
              'fill-opacity': 0.0
          });
          textHeading = draw.text('0').move((hudWidth/2),hudHeight-hdHeight+13);
          textHeading.font({
            fill: '#00ff00',
            anchor: 'middle',
            size: 23
          });
          
          hdTicksMask = heading.mask();
          
          hdTicksMask.rect(hudWidth, hudHeight).attr({
            fill: '#000000'         
          });
          hdTicksMask.rect(hdWidth, hdHeight).attr({  
            x: (hudWidth-hdWidth)/2, 
            y: hudHeight-hdHeight-5, 
            stroke: '#00ff00',
            'stroke-width': '1px',
            rx: 5,
            ry: 5,
            fill: '#ffffff'
          });
          hdTicksMask.polyline([
            [hudWidth/2, hudHeight-hdHeight-5],
            [(hudWidth+20)/2, hudHeight-hdHeight+10],
            [(hudWidth+hdCenterWidth)/2, hudHeight-hdHeight+10],
            [(hudWidth+hdCenterWidth)/2, hudHeight-5],
            [(hudWidth-hdCenterWidth)/2, hudHeight-5],
            [(hudWidth-hdCenterWidth)/2, hudHeight-hdHeight+10],
            [(hudWidth-20)/2, hudHeight-hdHeight+10],
            [hudWidth/2, hudHeight-hdHeight-5]]).attr({
            fill: '#000000'         
          });
          hdTicksArea.maskWith(hdTicksMask);
          
          /* -------------------------
                 Draw horizon
             ------------------------- */
          hrzWidth = (hudWidth-altWidth)*0.3;
          var hrzInterval;
          var horizonArea = draw.group();
          pxPerPitchLine = ((hudWidth/2) / posPitchLineOnScreen);
          pxPerDegreePitch = pxPerPitchLine / degPerPitchLine; 
          pitchIndicator = horizonArea.group();
          
          for(i = 0; i <= 90; i++)
          {
            if(i % degPerPitchLine == 0)
            {
              y = ((hudHeight)/2) - (pxPerDegreePitch * i);
              
              if(i>0)
              {
                pitchIndicator.polyline([
                  [(hudWidth-hrzWidth)/2, y],
                  [(hudWidth-(hrzWidth*0.10))/2, y],
                  [hudWidth/2, y+(hrzWidth*0.05)],
                  [(hudWidth+(hrzWidth*0.10))/2, y],
                  [(hudWidth+hrzWidth)/2, y]]).attr({
                  'stroke-width': 3,
                  stroke: '#ffffff'
                });
                pitchIndicator.polyline([
                  [(hudWidth-hrzWidth)/2, y],
                  [(hudWidth-(hrzWidth*0.10))/2, y],
                  [hudWidth/2, y+(hrzWidth*0.05)],
                  [(hudWidth+(hrzWidth*0.10))/2, y],
                  [(hudWidth+hrzWidth)/2, y]]).attr({
                  'stroke-width': 2,
                  stroke: '#00ff00'
                });
                         
                var fixedPitch = i;
                if(i > 90)
                {
                  fixedPitch = 180 - i;
                }
                
                var leftTextPitchLine = pitchIndicator.text(fixedPitch.toString()).move((hudWidth-hrzWidth)/2 - 5, y-7);
                leftTextPitchLine.font({
                  fill: '#00ff00',
                  anchor: 'end',
                  size: 15,
                });
                
                var rightTextPitchLine = pitchIndicator.text(fixedPitch.toString()).move((hudWidth+hrzWidth)/2 + 5, y-7);
                rightTextPitchLine.font({
                  fill: '#00ff00',
                  anchor: 'start',
                  size: 15,
                });
              }
              else
              {
                pitchIndicator.line(-hudWidth, y, 2*hudWidth, y).attr({
                  'stroke-width': 3,
                  stroke: '#ffffff'
                });
                pitchIndicator.line(-hudWidth, y, 2*hudWidth, y).attr({
                  'stroke-width': 2,
                  stroke: '#00ff00'
                });
              }
            }
          }         
          
          for(i = 0; i >= -90; i--)
          {
            if(i % degPerPitchLine == 0)
            {
              y = ((hudHeight)/2) - (pxPerDegreePitch * i);
              
              if(i<0)
              {
                pitchIndicator.polyline([
                  [(hudWidth-hrzWidth)/2, y],
                  [(hudWidth-(hrzWidth*0.10))/2, y],
                  [hudWidth/2, y-(hrzWidth*0.05)],
                  [(hudWidth+(hrzWidth*0.10))/2, y],
                  [(hudWidth+hrzWidth)/2, y]]).attr({
                  'stroke-width': 3,
                  stroke: '#ffffff'
                });
                pitchIndicator.polyline([
                  [(hudWidth-hrzWidth)/2, y],
                  [(hudWidth-(hrzWidth*0.10))/2, y],
                  [hudWidth/2, y-(hrzWidth*0.05)],
                  [(hudWidth+(hrzWidth*0.10))/2, y],
                  [(hudWidth+hrzWidth)/2, y]]).attr({
                  'stroke-width': 2,
                  stroke: '#00ff00'
                });
                           
                var fixedPitch = i;
                if(i < -90)
                {
                  fixedPitch = -180 - i;
                }
                
                var leftTextPitchLine = pitchIndicator.text(fixedPitch.toString()).move((hudWidth-hrzWidth)/2 - 5, y-7);
                leftTextPitchLine.font({
                  fill: '#00ff00',
                  anchor: 'end',
                  size: 15,
                });
                
                var rightTextPitchLine = pitchIndicator.text(fixedPitch.toString()).move((hudWidth+hrzWidth)/2 + 5, y-7);
                rightTextPitchLine.font({
                  fill: '#00ff00',
                  anchor: 'start',
                  size: 15,
                });
              }
            }
          }
          
          hrzMask = pitchIndicator.mask();
          hrzMask.rect(hudWidth, hudHeight).attr({
            fill: '#000000'     
          });
          hrzMask.rect(hudWidth-altWidth-20, hudHeight-hdHeight-20).attr({
            fill: '#ffffff',
            x: 5,
            y: 5
          });
          horizonArea.maskWith(hrzMask);
        }
      }
      
      var pitchDirection = 0.2;
      var altitudeDirection = 0.01;
        
        //var joystick  = new VirtualJoystick({
        //  container   : document.getElementById('touchpad2'),
        //  mouseSupport    : true,   
        //  limitStickTravel: true,
        //  stickRadius : 50,
        //});
        
        //joystick.addEventListener('touchStart', function(){
        //  console.log('down')
        //})
        //joystick.addEventListener('touchEnd', function(){
        //  console.log('up')
        //})
        
        //setInterval(function(){
        //  //var outputEl	= document.getElementById('result');
        //  console.log	= ' dx:'+joystick.deltaX()
        //    + ' dy:'+joystick.deltaY()
        //    + (joystick.right()	? ' right'	: '')
        //    + (joystick.up()	? ' up'	: '')
        //    + (joystick.left()	? ' left'	: '')
        //    + (joystick.down()	? ' down' : '')	
        //    }, 1/30 * 1000);
      
        
          //-Disable button when not in emergency state
          //sage.Subscribe('EIMARD2_ARDroneState_Emergency', function(signal) {
          //  if(signal.value) {
          //    $('#btn_reset_emergency_stop').removeClass("disabled");
          //  }
          //  else {
          //    $('#btn_reset_emergency_stop').addClass("disabled");
          //  }
          //});
          //
          //sage.Subscribe('EIMARD2_Theta', function(record) {
          //  angle = record.value / 1000;
          //  updateHUDPitch(angle);
          //});
          //        
          //sage.Subscribe('EIMARD2_Psi', function(record) {
          //  angle = record.value / 1000;
          //  if(angle < 0)
          //  {
          //    angle = 360.0 + angle;
          //  }
          //  updateHUDHeading(angle);
          //});
          //      
          //sage.Subscribe('EIMARD2_Phi', function(record) {
          //  angle = record.value / 1000;
          //  updateHUDRoll(-angle);
          //});
          //  
          //sage.Subscribe('EIMARD2_Altitude', function(record) {          
          //  meters = record.value / 1000;
          //  updateHUDAltitude(meters);
          //});
     
