extends ../common/layout

block header
  i.fa-fw.fa.fa-signal
  | Pilot Display (Test)

block main 
  .row
    article.col-xs-12.col-sm-12.col-md-6.col-lg-6
      #wid-Flight-HUD.jarviswidget.jarviswidget-color-blueDark(data-widget-editbutton='false',data-widget-colorbutton='false',data-widget-deletebutton='false')
        header
          span.widget-icon
            i.fa.fa-table
          h2 Attitude Indicator
        div
          .jarviswidget-editbox
            input.form-control(type='text')
          .widget-body(style='padding: 0px')
            #touchpad
              #hud(style='padding: 0px; margin-bottom: -5px;')

  script.
    var Position = {Lat: 0, Lon: 0, Alt: 0};
    var Attitude = {Yaw: 0, Pitch: 0, Roll: 0};
    var HUDCount = 0;
    var HUDStarted = false;

    //flyToLocation();

    /* Heads Up Display */

    var draw;
    var curHeading = 0;
    var curPitch = 0;
    var curRoll = 0;
    var curAltitude = 0.0;
    var textHeading;
    var hdTicks;
    var hdTicksMask;
    var hdWidth;
    var hudHeight;
    var hudWidth;
    var pxPer15Degrees;
    var pxPerDegree;
    var degPerPitchLine = 15;
    var posPitchLineOnScreen = 3.5;
    var pxPerPitchLine;
    var pxPerDegreePitch;
    var pitchIndicator;
    var altPosMetersOnScreen = 5;
    var altPxPerMeter;
    var altitudeIndicator;
    var textAltitude;
    var altTicks;
    var OffsetY = 0;
    var rotation = 0;
    var hrzWidth;
    var cameraImage;
    var imageBuffer;
    var tlm_o = new Telemetry();	
    tlm_o.subscribeTelemetry({
        homogeneity: {tolerance: 0.5}, tlm: [
          {name: '/MAV/CMN/A_pitch'},
          {name: '/MAV/CMN/A_roll'}]
      },
      function (params) {
        for (var i = 0; i < params.length; ++i) {
          switch (params[i].id.name) {
            case '/MAV/CMN/A_pitch':
              Attitude.Pitch = params[i].engValue.floatValue;
              break;

            case '/MAV/CMN/A_roll':
              Attitude.Roll = params[i].engValue.floatValue;
              break;
          }
        }

        if (HUDStarted == false) {
          /* Skip the first one. */
          HUDStarted = true;
        } else {
          HUDCount++;
        }
      }
    );
      
    setInterval(function () {
      if (HUDStarted == true) {
        updateHUDAltitude(Position.Alt);
        updateHUDHeading(Attitude.Yaw);
        updateHUDPitch(Attitude.Pitch * 57.2958);
        updateHUDRoll(Attitude.Roll * 57.2958);
      }
    }, 1000);

    drawHUD();

    function updateHUDHeading(newHeading) {
      textHeading.text(newHeading.toFixed(0).toString());
      hdTicks.x(-newHeading * pxPerDegree);
    }

    function updateHUDPitch(newPitch) {
      OffsetY = newPitch * pxPerDegreePitch;
      //pitchIndicator.rotate(0);
      //pitchIndicator.y(0);
      //pitchIndicator.animate(10, '-', 0).y(OffsetY).rotate(rotation);
    }

    function updateHUDRoll(newRoll) {
      rotation = newRoll;
      pitchIndicator.rotate(0);
      pitchIndicator.y(0);
      pitchIndicator.y(OffsetY).rotate(rotation);
    }

    function updateHUDAltitude(newAltitude) {
      textAltitude.text(newAltitude.toFixed(1).toString());
      altTicks.y(newAltitude * altPxPerMeter);
    }

    $('#hud').on('resize', function (event) {
      console.log("Resized");
      $('svg').remove();
      drawHUD();
      //updateHUDAltitude(10);
      //updateHUDHeading(20);
      //updateHUDPitch(30);
      //updateHUDRoll(40);
    });
    
    var toggle = 0;
    vid.getVideoStream(function(image) {
      imageBuffer = image.data;
      console.log('framr');
      cameraImage.load('data:image/jpeg;base64,' + imageBuffer);
    });

    function drawHUD() {
      var aspectRatio = 320.0 / 180.0;
      hudWidth = $('#hud').width();
      hudHeight = hudWidth / aspectRatio;
      if ($(window).height() < hudHeight) {
        hudHeight = $(window).height() - 50;
        hudWidth = hudHeight * aspectRatio;
      }
      draw = SVG('hud').size('100%', hudHeight);

      if (SVG.supported == false) {
        alert('SVG not supported with ths browser.');
      }
      else {
        var bgOpacity = 0.5;
        var rect = draw.rect('100%', '100%').attr({fill: '#000000'});
        //draw.fixSubPixelOffset();
        draw.attr('preserveAspectRatio', 'x320Y180 meet');

        /* -------------------------
         Draw the camera video
         ------------------------- */
        //var defs = draw.defs();
        //var cameraVideoClip = defs.clip().rect(hudWidth, hudHeight).move(0, 0);
        cameraImage = draw.image('data:image/jpeg;base64,' + imageBuffer, hudWidth, hudHeight);

        var rollIndicator = draw.group();

        /* -------------------------
         Draw altimeter
         ------------------------- */
        var altWidth = 50;
        var altHeight = hudHeight - 10;
        var altWidth = 50;
        var altHeight = hudHeight - 10;
        altPxPerMeter = altHeight / altPosMetersOnScreen;
        var altPxPerDecimeter = altPxPerMeter / 10.0;
        var altPxPerCentimeter = altPxPerMeter / 100.0;
        var altPxPerMillimeter = altPxPerMeter / 1000.0;

        var altimeter = draw.group();
        var altBorder = altimeter.group();
        /* Draw border. */
        var altRec1 = altBorder.rect(altWidth, altHeight).attr({
          x: hudWidth - altWidth - 5,
          y: 5,
          stroke: '#000000',
          'stroke-width': '3px',
          rx: 5,
          ry: 5,
          'fill-opacity': bgOpacity
        });
        var altRec2 = altBorder.rect(altWidth, altHeight).attr({
          x: hudWidth - altWidth - 5,
          y: 5,
          stroke: '#00ff00',
          rx: 5,
          ry: 5,
          'fill-opacity': bgOpacity
        });
        /* Draw ticks group. */
        var altTicksArea = altimeter.group();
        altTicks = altTicksArea.group();
        for (i = 0; i < (10 * (altPosMetersOnScreen + 1 + 30)); i++) {
          y = (hudHeight / 2) - i * (altPxPerDecimeter);
          /* Draw a longer line if its a meter interval. */
          if (i % 10 == 0) {
            altTicks.line(hudWidth - altWidth - 3, y, hudWidth - altWidth + 20, y).attr({
              width: 2,
              stroke: '#00ff00'
            });

            var textAltTick = altTicks.text((i / 10.0).toString()).move(hudWidth - altWidth + 30, y - 5);
            textAltTick.font({
              fill: '#00ff00',
              anchor: 'start',
              size: 13
            });
          }
          else {
            /* This is just a decimeter tick. */
            altTicks.line(hudWidth - altWidth - 3, y, hudWidth - altWidth + 10, y).attr({
              width: 1,
              stroke: '#00ff00'
            });
          }
        }
        for (i = 0; i > (-10 * (altPosMetersOnScreen + 1)); i--) {
          y = (hudHeight / 2) - i * (altPxPerDecimeter);
          /* Draw a longer line if its a meter interval. */
          if (i % 10 == 0) {
            altTicks.line(hudWidth - altWidth - 3, y, hudWidth - altWidth + 20, y).attr({
              width: 2,
              stroke: '#00ff00'
            });

            var textAltTick = altTicks.text((i / 10.0).toString()).move(hudWidth - altWidth + 30, y - 5);
            textAltTick.font({
              fill: '#00ff00',
              anchor: 'start',
              size: 13
            });
          }
          else {
            /* This is just a decimeter tick. */
            altTicks.line(hudWidth - altWidth - 3, y, hudWidth - altWidth + 10, y).attr({
              width: 1,
              stroke: '#00ff00'
            });
          }
        }
        /* Draw center altitude indicator. */
        var altCenter = altimeter.group();
        var altCenterHeight = 30;
        altCenter.polyline([
          [hudWidth - altWidth - 5, hudHeight / 2],
          [hudWidth - altWidth + 15, (hudHeight - altCenterHeight) / 2],
          [hudWidth - 5, (hudHeight - altCenterHeight) / 2],
          [hudWidth - 5, (hudHeight + altCenterHeight) / 2],
          [hudWidth - altWidth + 15, (hudHeight + altCenterHeight) / 2],
          [hudWidth - altWidth - 5, hudHeight / 2]]).attr({
          stroke: '#000000',
          'stroke-width': 3,
          'fill-opacity': 0.0
        });
        altCenter.polyline([
          [hudWidth - altWidth - 5, hudHeight / 2],
          [hudWidth - altWidth + 15, (hudHeight - altCenterHeight) / 2],
          [hudWidth - 5, (hudHeight - altCenterHeight) / 2],
          [hudWidth - 5, (hudHeight + altCenterHeight) / 2],
          [hudWidth - altWidth + 15, (hudHeight + altCenterHeight) / 2],
          [hudWidth - altWidth - 5, hudHeight / 2]]).attr({
          stroke: '#00ff00',
          'stroke-width': 2,
          'fill-opacity': 0.0
        });
        textAltitude = altCenter.text('0.0').move(hudWidth - altWidth + 14, (hudHeight / 2) - 9);
        //textAltitude.attr("dominant-baseline", "middle");
        textAltitude.font({
          fill: '#00ff00',
          size: 18
        });
        var altTicksMask = altimeter.mask();
        altTicksMask.rect(hudWidth, hudHeight).attr({
          fill: '#000000'
        });
        altTicksMask.rect(altWidth, altHeight).attr({
          x: hudWidth - altWidth - 5,
          y: 5,
          fill: '#ffffff',
          'stroke-width': '3px',
          rx: 5,
          ry: 5
        });
        altTicksMask.polyline([
          [hudWidth - altWidth - 5, hudHeight / 2],
          [hudWidth - altWidth + 15, (hudHeight - altCenterHeight) / 2],
          [hudWidth - 5, (hudHeight - altCenterHeight) / 2],
          [hudWidth - 5, (hudHeight + altCenterHeight) / 2],
          [hudWidth - altWidth + 15, (hudHeight + altCenterHeight) / 2],
          [hudWidth - altWidth - 5, hudHeight / 2]]).attr({
          fill: '#000000'
        });
        altTicksArea.maskWith(altTicksMask);

        /* -------------------------
         Draw Heading
         ------------------------- */
        var hdHeight = 50;
        hdWidth = hudWidth - 120;
        pxPer15Degrees = (hdWidth / 2) / 5;
        pxPerDegree = pxPer15Degrees / 15.0;
        var heading = draw.group();
        var headingBorder = heading.group();
        /* Draw border. */
        var hdRec1 = headingBorder.rect(hdWidth, hdHeight).attr({
          x: (hudWidth - hdWidth) / 2,
          y: hudHeight - hdHeight - 5,
          stroke: '#000000',
          'stroke-width': '3px',
          rx: 5,
          ry: 5,
          'fill-opacity': bgOpacity
        });
        var hdRec2 = headingBorder.rect(hdWidth, hdHeight).attr({
          x: (hudWidth - hdWidth) / 2,
          y: hudHeight - hdHeight - 5,
          stroke: '#00ff00',
          'stroke-width': '1px',
          rx: 5,
          ry: 5,
          'fill-opacity': bgOpacity
        });
        /* Draw ticks group. */
        hdTicksArea = heading.group();
        hdTicks = hdTicksArea.group();
        for (i = 0; i < (360 + 90); i++) {
          if (i % 15 == 0) {
            x = ((hudWidth) / 2) + (pxPerDegree * i);
            hdTicks.line(x, hudHeight - hdHeight - 3, x, hudHeight - hdHeight + 10).attr({
              width: 1,
              stroke: '#00ff00'
            });

            var fixedHeading = i;
            if (i < 0) {
              fixedHeading = 360 + i;
            }
            else if (i >= 360) {
              fixedHeading = i - 360;
            }

            var textHeadingTick = hdTicks.text(fixedHeading.toString()).move(x, hudHeight - hdHeight + 13);
            textHeadingTick.font({
              fill: '#00ff00',
              anchor: 'middle',
              size: 13
            });
          }
        }
        for (i = 0; i > (-360 - 90); i--) {
          if (i % 15 == 0) {
            x = ((hudWidth) / 2) + (pxPerDegree * i);
            hdTicks.line(x, hudHeight - hdHeight - 3, x, hudHeight - hdHeight + 10).attr({
              width: 1,
              stroke: '#00ff00'
            });

            var fixedHeading = i;
            if (i < 0) {
              fixedHeading = 360 + i;
            }
            else if (i >= 360) {
              fixedHeading = i - 360;
            }

            var textHeadingTick = hdTicks.text(fixedHeading.toString()).move(x, hudHeight - hdHeight + 13);
            textHeadingTick.font({
              fill: '#00ff00',
              anchor: 'middle',
              size: 13
            });
          }
        }
        /* Draw center heading indicator. */
        var hdCenter = heading.group();
        var hdCenterWidth = 60;
        hdCenter.polyline([
          [hudWidth / 2, hudHeight - hdHeight - 5],
          [(hudWidth + 20) / 2, hudHeight - hdHeight + 10],
          [(hudWidth + hdCenterWidth) / 2, hudHeight - hdHeight + 10],
          [(hudWidth + hdCenterWidth) / 2, hudHeight - 5],
          [(hudWidth - hdCenterWidth) / 2, hudHeight - 5],
          [(hudWidth - hdCenterWidth) / 2, hudHeight - hdHeight + 10],
          [(hudWidth - 20) / 2, hudHeight - hdHeight + 10],
          [hudWidth / 2, hudHeight - hdHeight - 5]]).attr({
          stroke: '#000000',
          'stroke-width': 3,
          'fill-opacity': 0.0
        });
        hdCenter.polyline([
          [hudWidth / 2, hudHeight - hdHeight - 5],
          [(hudWidth + 20) / 2, hudHeight - hdHeight + 10],
          [(hudWidth + hdCenterWidth) / 2, hudHeight - hdHeight + 10],
          [(hudWidth + hdCenterWidth) / 2, hudHeight - 5],
          [(hudWidth - hdCenterWidth) / 2, hudHeight - 5],
          [(hudWidth - hdCenterWidth) / 2, hudHeight - hdHeight + 10],
          [(hudWidth - 20) / 2, hudHeight - hdHeight + 10],
          [hudWidth / 2, hudHeight - hdHeight - 5]]).attr({
          stroke: '#00ff00',
          'stroke-width': 2,
          'fill-opacity': 0.0
        });
        textHeading = draw.text('0').move((hudWidth / 2), hudHeight - hdHeight + 13);
        textHeading.font({
          fill: '#00ff00',
          anchor: 'middle',
          size: 23
        });

        hdTicksMask = heading.mask();

        hdTicksMask.rect(hudWidth, hudHeight).attr({
          fill: '#000000'
        });
        hdTicksMask.rect(hdWidth, hdHeight).attr({
          x: (hudWidth - hdWidth) / 2,
          y: hudHeight - hdHeight - 5,
          stroke: '#00ff00',
          'stroke-width': '1px',
          rx: 5,
          ry: 5,
          fill: '#ffffff'
        });
        hdTicksMask.polyline([
          [hudWidth / 2, hudHeight - hdHeight - 5],
          [(hudWidth + 20) / 2, hudHeight - hdHeight + 10],
          [(hudWidth + hdCenterWidth) / 2, hudHeight - hdHeight + 10],
          [(hudWidth + hdCenterWidth) / 2, hudHeight - 5],
          [(hudWidth - hdCenterWidth) / 2, hudHeight - 5],
          [(hudWidth - hdCenterWidth) / 2, hudHeight - hdHeight + 10],
          [(hudWidth - 20) / 2, hudHeight - hdHeight + 10],
          [hudWidth / 2, hudHeight - hdHeight - 5]]).attr({
          fill: '#000000'
        });
        hdTicksArea.maskWith(hdTicksMask);

        /* -------------------------
         Draw horizon
         ------------------------- */
        hrzWidth = (hudWidth - altWidth) * 0.3;
        var hrzInterval;
        var horizonArea = draw.group();
        pxPerPitchLine = ((hudWidth / 2) / posPitchLineOnScreen);
        pxPerDegreePitch = pxPerPitchLine / degPerPitchLine;
        pitchIndicator = horizonArea.group();

        for (i = 0; i <= 90; i++) {
          if (i % degPerPitchLine == 0) {
            y = ((hudHeight) / 2) - (pxPerDegreePitch * i);

            if (i > 0) {
              pitchIndicator.polyline([
                [(hudWidth - hrzWidth) / 2, y],
                [(hudWidth - (hrzWidth * 0.10)) / 2, y],
                [hudWidth / 2, y + (hrzWidth * 0.05)],
                [(hudWidth + (hrzWidth * 0.10)) / 2, y],
                [(hudWidth + hrzWidth) / 2, y]]).attr({
                'stroke-width': 3,
                'fill-opacity': 0.0,
                stroke: '#000000'
              });
              pitchIndicator.polyline([
                [(hudWidth - hrzWidth) / 2, y],
                [(hudWidth - (hrzWidth * 0.10)) / 2, y],
                [hudWidth / 2, y + (hrzWidth * 0.05)],
                [(hudWidth + (hrzWidth * 0.10)) / 2, y],
                [(hudWidth + hrzWidth) / 2, y]]).attr({
                'stroke-width': 2,
                'fill-opacity': 0.0,
                stroke: '#00ff00'
              });

              var fixedPitch = i;
              if (i > 90) {
                fixedPitch = 180 - i;
              }

              pitchIndicator.rect(20, 20).attr({
                fill: '#000000',
                x: (hudWidth - hrzWidth) / 2 - 22,
                y: y - 10,
                'fill-opacity': bgOpacity,
              });
              var leftTextPitchLine = pitchIndicator.text(fixedPitch.toString()).move((hudWidth - hrzWidth) / 2 - 5, y - 7);
              leftTextPitchLine.font({
                fill: '#00ff00',
                anchor: 'end',
                size: 15,
              });

              pitchIndicator.rect(20, 20).attr({
                fill: '#000000',
                x: (hudWidth + hrzWidth) / 2 + 3,
                y: y - 10,
                'fill-opacity': bgOpacity,
              });
              var rightTextPitchLine = pitchIndicator.text(fixedPitch.toString()).move((hudWidth + hrzWidth) / 2 + 5, y - 7);
              rightTextPitchLine.font({
                fill: '#00ff00',
                anchor: 'start',
                size: 15,
              });
            }
            else {
              pitchIndicator.line(-hudWidth, y, 2 * hudWidth, y).attr({
                'stroke-width': 3,
                stroke: '#000000'
              });
              pitchIndicator.line(-hudWidth, y, 2 * hudWidth, y).attr({
                'stroke-width': 2,
                stroke: '#00ff00'
              });
            }
          }
        }

        for (i = 0; i >= -90; i--) {
          if (i % degPerPitchLine == 0) {
            y = ((hudHeight) / 2) - (pxPerDegreePitch * i);

            if (i < 0) {
              pitchIndicator.polyline([
                [(hudWidth - hrzWidth) / 2, y],
                [(hudWidth - (hrzWidth * 0.10)) / 2, y],
                [hudWidth / 2, y - (hrzWidth * 0.05)],
                [(hudWidth + (hrzWidth * 0.10)) / 2, y],
                [(hudWidth + hrzWidth) / 2, y]]).attr({
                'stroke-width': 3,
                'fill-opacity': 0.0,
                stroke: '#000000'
              });
              pitchIndicator.polyline([
                [(hudWidth - hrzWidth) / 2, y],
                [(hudWidth - (hrzWidth * 0.10)) / 2, y],
                [hudWidth / 2, y - (hrzWidth * 0.05)],
                [(hudWidth + (hrzWidth * 0.10)) / 2, y],
                [(hudWidth + hrzWidth) / 2, y]]).attr({
                'stroke-width': 2,
                'fill-opacity': 0.0,
                stroke: '#00ff00'
              });

              var fixedPitch = i;
              if (i < -90) {
                fixedPitch = -180 - i;
              }

              pitchIndicator.rect(25, 20).attr({
                fill: '#000000',
                x: (hudWidth - hrzWidth) / 2 - 27,
                y: y - 10,
                'fill-opacity': bgOpacity,
              });
              var leftTextPitchLine = pitchIndicator.text(fixedPitch.toString()).move((hudWidth - hrzWidth) / 2 - 5, y - 7);
              leftTextPitchLine.font({
                fill: '#00ff00',
                anchor: 'end',
                size: 15,
              });

              pitchIndicator.rect(25, 20).attr({
                fill: '#000000',
                x: (hudWidth + hrzWidth) / 2 + 3,
                y: y - 10,
                'fill-opacity': bgOpacity,
              });
              var rightTextPitchLine = pitchIndicator.text(fixedPitch.toString()).move((hudWidth + hrzWidth) / 2 + 5, y - 7);
              rightTextPitchLine.font({
                fill: '#00ff00',
                anchor: 'start',
                size: 15,
              });
            }
          }
        }

        hrzMask = pitchIndicator.mask();
        hrzMask.rect(hudWidth, hudHeight).attr({
          fill: '#000000'
        });
        hrzMask.rect(hudWidth - altWidth - 20, hudHeight - hdHeight - 20).attr({
          fill: '#ffffff',
          x: 5,
          y: 5
        });
        horizonArea.maskWith(hrzMask);
      }
    }

    var pitchDirection = 0.2;
    var altitudeDirection = 0.01;
